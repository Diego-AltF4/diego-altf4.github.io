[{"content":"TL;DR In this challenge we can obtain the value of s in a fast way (8 seconds) applying Fermat\u0026rsquo;s little theorem. It is necessary to adapt our case to be able to use it.\nChallenge description I have designed a revised RSA algorithm which I believe it’s more secure. I am confident you cannot compromise my message with the p value. Meanwhile, it’s time-consuming to complete the encryption. You may need more effort to brute force it as it takes much longer to complete the encryption.\nCode analysis First of all, it is important to understand the source code\nSource code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34; Created on Wed Nov 23 22:26:57 2022 @author: weiping \u0026#34;\u0026#34;\u0026#34; import os import random from Crypto.Util.number import * import gmpy2 flag = b\u0026#39;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\u0026#39; class RSA(): def __init__(self): self.p = getPrime(512) self.s = 0 for i in range(1, 18000000): self.s += pow(i, self.p-2, self.p) self.s = self.s % self.p self.q = gmpy2.next_prime(self.s) self.n = self.p * self.q self.phi = (self.p - 1) * (self.q - 1) self.e = 65537 self.d = pow(self.e, -1, self.phi) def encrypt(self, m: int): return pow(m, self.e, self.n) def main(): rsa = RSA() print(f\u0026#34;p = {rsa.p}\u0026#34;) print(f\u0026#34;e = {rsa.e}\u0026#34;) c = rsa.encrypt(bytes_to_long(flag)) print(\u0026#39;c = \u0026#39;, c) \u0026#39;\u0026#39;\u0026#39; p = 11545307730112922786664290405312669819594345207377186481347514368962838475959085036399074594822885814719354871659183685801279739518405830244888530641898849 e = 65537 c = 114894293598203268417380013863687165686775727976061560608696207173455730179934925684529986102237419507146768083815607566149240438056135058988227916482404733131796310418493418060300571541865427288945087911872630289527954636816219365941817260989104786329938318143577075200571833575709614521758701838099810751 \u0026#39;\u0026#39;\u0026#39; if __name__ == \u0026#34;__main__\u0026#34;: main() As you can see, we have the value of p, e and c, but we do not have n. If we look at it, we can see that it generates s by doing 18000000 powers and gets q thanks to the value of s. Therefore, we have to try to get the value of s.\nMathematical approach The goal is to reduce the time required to calculate s.\nFollowing Fermat\u0026rsquo;s little theorem:\n$$ a^{p-1}\\hspace{0.2cm}(mod\\hspace{0.2cm}p) = 1 $$ When p is prime. Applying it to our case $$ s = a^{p-2}\\hspace{0.2cm}(mod\\hspace{0.2cm}p) = \\frac{a^{p-1}}{a}\\hspace{0.2cm}(mod\\hspace{0.2cm}p) $$ therefore, we only have to calculate: $$ s = \\frac{1}{a}\\hspace{0.2cm}(mod\\hspace{0.2cm}p) $$\nBy calculating the inverse of the iterator, we can quickly obtain the increment of s.\nSolver Let\u0026rsquo;s put the idea into action\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #!/usr/bin/env python import os import random from Crypto.Util.number import * import gmpy2 p = 11545307730112922786664290405312669819594345207377186481347514368962838475959085036399074594822885814719354871659183685801279739518405830244888530641898849 s = 0 for i in range(1, 18000000): s += gmpy2.invert(i, p) print(f\u0026#34;{s = }\u0026#34;) s = s % p q = gmpy2.next_prime(s) n = p * q c = 114894293598203268417380013863687165686775727976061560608696207173455730179934925684529986102237419507146768083815607566149240438056135058988227916482404733131796310418493418060300571541865427288945087911872630289527954636816219365941817260989104786329938318143577075200571833575709614521758701838099810751 e = 65537 phi = (p-1) * (q-1) d = pow(e, -1, phi) m = pow(c, d, n) print(long_to_bytes(m)) If we execute it, we can see that we get the flag:\n1 2 3 4 ❯ time python3 solver2.py s = mpz(103971141938451865359424516052456680043111979970687239680103277440181119667242055656649027253774602707619853688444079038238256982869565035713747893569070903914899) b\u0026#39;TUCTF{syqow82pam_%shsjQF; ^7dagsWCpsp_#aes}\u0026#39; python3 solver2.py 7,96s user 0,02s system 99% cpu 7,980 total I hope you liked it and learned.\n","date":"2022-12-04T00:00:00Z","image":"https://example.com/p/more-effort-writeup-tuctf/coverMoreEffort2_hu6db6baebb0f556ab3244dd2b5311e772_1143741_120x120_fill_box_smart1_3.png","permalink":"https://example.com/p/more-effort-writeup-tuctf/","title":" More Effort Writeup | TUCTF"},{"content":"TL;DR In order to get the flag, we have to get a number that when we pass it to the Miller Rabin primality test, it returns that it is not prime and, if we pass it to the isPrime function of the Crypto.Util.number library, it tells us that it is prime. Therefore, we have to fool the Miller Rabin algorithm. To do this, we can use Carmichael\u0026rsquo;s numbers.\nCode analysis First of all, it is important to understand the source code\nSource code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 from secret import FLAG from Crypto.Util.number import isPrime import socketserver import signal class Handler(socketserver.BaseRequestHandler): def handle(self): signal.alarm(0) main(self.request) class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass def sendMessage(s, msg): s.send(msg.encode()) def receiveMessage(s, msg): sendMessage(s, msg) return s.recv(4096).decode().strip() def generate_basis(n): basis = [True] * n for i in range(3, int(n**0.5) + 1, 2): if basis[i]: basis[i * i::2 * i] = [False] * ((n - i * i - 1) // (2 * i) + 1) return [2] + [i for i in range(3, n, 2) if basis[i]] def millerRabin(n, b): basis = generate_basis(300) if n == 2 or n == 3: return True if n % 2 == 0: return False r, s = 0, n - 1 while s % 2 == 0: r += 1 s //= 2 for b in basis: x = pow(b, s, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True def _isPrime(p): if p \u0026lt; 1: return False if (p.bit_length() \u0026lt;= 600) and (p.bit_length() \u0026gt; 1500): return False if not millerRabin(p, 300): return False return True def main(s): p = receiveMessage(s, \u0026#34;Give p: \u0026#34;) try: p = int(p) except: sendMessage(s, \u0026#34;Error!\u0026#34;) if _isPrime(p) and not isPrime(p): sendMessage(s, FLAG) else: sendMessage(s, \u0026#34;Conditions not satisfied!\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: socketserver.TCPServer.allow_reuse_address = True server = ReusableTCPServer((\u0026#34;0.0.0.0\u0026#34;, 1337), Handler) server.serve_forever() To obtain the flag we have to pass these checks:\n1 if _isPrime(p) and not isPrime(p): The function _isPrime calls millerRabin and isPrime calls such function from the Crypto.Util.number library.\nSolver Surfing the Internet, we can see that Carmichael numbers have a particular relationship with primality tests based on Fermat\u0026rsquo;s Little Theorem such as Miller-Rabin.\nHere you can find information about Carmichael\u0026rsquo;s numbers: https://en.wikipedia.org/wiki/Carmichael_number\nThe most important part is:\nThis makes tests based on Fermat\u0026rsquo;s Little Theorem less effective than strong probable prime tests such as the Baillie–PSW primality test and the Miller–Rabin primality test.\nThus, we can try to use this information to bypass the check. We can calculate a Carmichael number following the information in wikipedia:\n1 2 3 4 #!/usr/bin/env python p = 29674495668685510550154174642905332730771991799853043350995075531276838753171770199594238596428121188033664754218345562493168782883 number = p * (313 * (p-1) + 1 ) * (353 * (p-1) + 1) print(f\u0026#34;{number = }\u0026#34;) If we execute it, we can see that we get the number:\n1 Number = 2887148238050771212671429597130393991977609459279722700926516024197432303799152733116328983144639225941977803110929349655578418949441740933805615113979999421542416933972905423711002751042080134966731755152859226962916775325475044445856101949404200039904432116776619949629539250452698719329070373564032273701278453899126120309244841494728976885406024976768122077071687938121709811322297802059565867 Flag:\n1 2 3 ❯ nc 176.61.85.130 31431 Give p: 2887148238050771212671429597130393991977609459279722700926516024197432303799152733116328983144639225941977803110929349655578418949441740933805615113979999421542416933972905423711002751042080134966731755152859226962916775325475044445856101949404200039904432116776619949629539250452698719329070373564032273701278453899126120309244841494728976885406024976768122077071687938121709811322297802059565867 HTB{c42m1ch431_num8325_423_fun_p53ud0p21m35} I hope you liked it and learned.\n","date":"2022-10-28T00:00:00Z","image":"https://example.com/p/fast-carmichael-writeup-hack-the-boo/CarmichaelCover_hu5ea5adbdd50db7b3134bd92c79e59143_1586316_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/fast-carmichael-writeup-hack-the-boo/","title":"Fast Carmichael Writeup | Hack The Boo"},{"content":"It is a simple challenge, but it is necessary to realize how to obtain f. Something that, initially, can be a bit tricky.\nTL;DR We can obtain the value of f if we apply GCD on C1-C2 and N\nCode analysis First of all, it is important to understand the source code\nSource code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from Crypto.Util.number import bytes_to_long, getStrongPrime from random import randint FLAG = b\u0026#39;HTB{????????????????????????????????????????????}\u0026#39; def key_gen(bits): p, q = getStrongPrime(bits), getStrongPrime(bits) N = p * q return N, (p, q) def encrypt(m, N, f): e1, e2 = randint(2, N - 2), randint(2, N - 2) c1 = (pow(f, e1, N) + m) % N c2 = (pow(f, e2, N) + m) % N return (e1, c1), (e2, c2) def main(): N, priv = key_gen(1024) m = bytes_to_long(FLAG) (e1, c1), (e2, c2) = encrypt(m, N, priv[0]) with open(\u0026#39;out.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(f\u0026#39;N = {N}\\n(e1, c1) = ({e1}, {c1})\\n(e2, c2) = ({e2}, {c2})\\n\u0026#39;) if __name__ == \u0026#34;__main__\u0026#34;: main() Output:\n1 2 3 N = 25458200992030509733740123651871827168179694737564741891817013763410533831135578900317404987414083347009443171337016804117994550747038777609425522146275786823385218489896468142658492353321920860029284041857237273061376882168336089921980034356731735024837853873907395117925738744950932927683784527829300499629044776530663084875991411120648155572219472426590747952180037566734905079883718263249789131313731453855593891997376222635496337534679814697188141565730768050813250191975439504290665602928172394124501396491438097237093345376202142503439944034846839870643057174427346860377971316738504003909365471892007511334129 (e1, c1) = (22255763231110249841946619835451544743470788953822278626567823902873888725104180401047359514978597528256727783972109939326623409435352523707077685530090905587264556011558283062584063790610407522064244766804545192800000203519996147931257064951519705687708204481851413899370853107413015511963924826116255617048471033727588623329910848658324118717242497443676679226618430348230146770121025920211016222285978389380202889753020268614144716241830764562717015776308425373054119742788593926393822433887270639369774139542440755201713961244129409678232953199572105700556795757766046717275157050721726002297647024020428198870290, 19074438470072195427966520314234457847008607427606084653244579403273587717215359437848959151287968653813774451872243596539852961112790372328452176435310940366312355444995843216994547119328105950997441430508803799696108202263077660206667410037895728991246260073976495701990246589717169815787627260333746927676703415397948299928151669728670970891826725671026488571268125861689964688240713660432174319415041362820791863237794347031803574182264640071528640168842529541888996148513070006266317160300336104047046565614107490019016833308549850299600989228190163831642944507973854553499903518264459385900876967183424703346566) (e2, c2) = (23295046285127774160603234291301851851887586336491694096135804083341667982196486623010787985772884401302006627480506928365762168889259124596656609547973623161028214128429382170008181185180817200188852310143707964673736007253037970626819969310508212349854949150027746456459910448148518206090222496335254237639366458956363901115228820515207791697374943745570543635069929211464017776268424656451494147324386568859163866168248303418756480467046005765139197217754018136577337642795325944222997798231137981998354508181409469926672642302422740898720854693114056342834487668008885129303781190655860432910789997267090661459286, 17147905252678781157626731164660022679389951402035723790864177724472811805536492684462105274963820085525923148442586230016346022360533813239980197823588694113614328942373594914090007235565086360669401527248700861049825216638433673668883632064731716051799766945737234155585371938261291032941617911654796216200373195747432329591657679097825944679339369336644061159658436125778459206858632826310294115276289447751653250081978372776233383658861171699105292372718533428579168281346425439711770636421673291051002416067073005799659684303566722822458673952580001750804105442227754799536262315625088085767607467446614116889593) Mathematical approach The goal is to try to clear f so that we can factor N easily:\n$$ c1 - c2 \\cong (f^{e1} - f^{e2}) \\times \\frac{f}{f}\\hspace{0.2cm}(mod\\hspace{0.2cm}N) $$ Also, we know that: $$ (f^{e1} - f^{e2}) \\times \\frac{f}{f} = \\frac{f^{e1}}{f} - \\frac{f^{e2}}{f} = (f^{e1} \\times f^{-1}) - (f^{e2} - f^{-1}) = (f^{e1-1} - f^{e2-1}) \\times f $$ therefore: $$ c1 - c2 \\cong (f^{e1-1} - f^{e2-1}) \\times f\\hspace{0.2cm}(mod\\hspace{0.2cm}N) $$\nAdditionally, we know that:\n$$ N = f * q $$\nwe can eliminate the congruence and formulate it as follows:\n$$ c1 - c2 = f \\times (f^{e1-1} - p^{e2-1}) + (k \\times f \\times q) $$\nWe are very close to achieving this\n$$ c1 - c2 = f \\times (f^{e1-1} - p^{e2-1} + k \\times q) $$\nWe have already succeeded in isolating the f. So if we apply the GCD on this expression and N, we will obtain f. $$ f = \\gcd{(C1-C2, N)} $$\nSolver Let\u0026rsquo;s put the idea into action\n1 2 3 4 5 6 7 8 9 10 11 #!/usr/bin/env python from Crypto.Util.number import * N = 25458200992030509733740123651871827168179694737564741891817013763410533831135578900317404987414083347009443171337016804117994550747038777609425522146275786823385218489896468142658492353321920860029284041857237273061376882168336089921980034356731735024837853873907395117925738744950932927683784527829300499629044776530663084875991411120648155572219472426590747952180037566734905079883718263249789131313731453855593891997376222635496337534679814697188141565730768050813250191975439504290665602928172394124501396491438097237093345376202142503439944034846839870643057174427346860377971316738504003909365471892007511334129 (e1, c1) = (22255763231110249841946619835451544743470788953822278626567823902873888725104180401047359514978597528256727783972109939326623409435352523707077685530090905587264556011558283062584063790610407522064244766804545192800000203519996147931257064951519705687708204481851413899370853107413015511963924826116255617048471033727588623329910848658324118717242497443676679226618430348230146770121025920211016222285978389380202889753020268614144716241830764562717015776308425373054119742788593926393822433887270639369774139542440755201713961244129409678232953199572105700556795757766046717275157050721726002297647024020428198870290, 19074438470072195427966520314234457847008607427606084653244579403273587717215359437848959151287968653813774451872243596539852961112790372328452176435310940366312355444995843216994547119328105950997441430508803799696108202263077660206667410037895728991246260073976495701990246589717169815787627260333746927676703415397948299928151669728670970891826725671026488571268125861689964688240713660432174319415041362820791863237794347031803574182264640071528640168842529541888996148513070006266317160300336104047046565614107490019016833308549850299600989228190163831642944507973854553499903518264459385900876967183424703346566) (e2, c2) = (23295046285127774160603234291301851851887586336491694096135804083341667982196486623010787985772884401302006627480506928365762168889259124596656609547973623161028214128429382170008181185180817200188852310143707964673736007253037970626819969310508212349854949150027746456459910448148518206090222496335254237639366458956363901115228820515207791697374943745570543635069929211464017776268424656451494147324386568859163866168248303418756480467046005765139197217754018136577337642795325944222997798231137981998354508181409469926672642302422740898720854693114056342834487668008885129303781190655860432910789997267090661459286, 17147905252678781157626731164660022679389951402035723790864177724472811805536492684462105274963820085525923148442586230016346022360533813239980197823588694113614328942373594914090007235565086360669401527248700861049825216638433673668883632064731716051799766945737234155585371938261291032941617911654796216200373195747432329591657679097825944679339369336644061159658436125778459206858632826310294115276289447751653250081978372776233383658861171699105292372718533428579168281346425439711770636421673291051002416067073005799659684303566722822458673952580001750804105442227754799536262315625088085767607467446614116889593) f = GCD(N, c1 - c2) m = long_to_bytes(c1 - pow(f, e1, N) % N) print(m) If we execute it, we can see that we get the flag:\nFlag:\n1 2 ❯ python3 solverSpookyRSA.py b\u0026#39;HTB{5h45_w4$_sUpp0s3d_50_b3_m0r3_s3cUr3_th4n_R$4}\u0026#39; I hope you liked it and learned.\n","date":"2022-10-28T00:00:00Z","image":"https://example.com/p/spooky-rsa-writeup-hack-the-boo/coverSpookyGrey2_hud0bc4ac7a7e710e3c50db796ed01cdff_1387720_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/spooky-rsa-writeup-hack-the-boo/","title":"Spooky RSA Writeup | Hack The Boo"}]