[{"content":"TL;DR In this challenge we can obtain the value of s in a fast way (8 seconds) by applying Fermat\u0026rsquo;s little theorem. It is necessary to adapt our case to be able to use it.\nChallenge description I have designed a revised RSA algorithm which I believe it’s more secure. I am confident you cannot compromise my message with the p value. Meanwhile, it’s time-consuming to complete the encryption. You may need more effort to brute force it as it takes much longer to complete the encryption.\nCode analysis First of all, it is important to understand the source code\nSource code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34; Created on Wed Nov 23 22:26:57 2022 @author: weiping \u0026#34;\u0026#34;\u0026#34; import os import random from Crypto.Util.number import * import gmpy2 flag = b\u0026#39;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\u0026#39; class RSA(): def __init__(self): self.p = getPrime(512) self.s = 0 for i in range(1, 18000000): self.s += pow(i, self.p-2, self.p) self.s = self.s % self.p self.q = gmpy2.next_prime(self.s) self.n = self.p * self.q self.phi = (self.p - 1) * (self.q - 1) self.e = 65537 self.d = pow(self.e, -1, self.phi) def encrypt(self, m: int): return pow(m, self.e, self.n) def main(): rsa = RSA() print(f\u0026#34;p = {rsa.p}\u0026#34;) print(f\u0026#34;e = {rsa.e}\u0026#34;) c = rsa.encrypt(bytes_to_long(flag)) print(\u0026#39;c = \u0026#39;, c) \u0026#39;\u0026#39;\u0026#39; p = 11545307730112922786664290405312669819594345207377186481347514368962838475959085036399074594822885814719354871659183685801279739518405830244888530641898849 e = 65537 c = 114894293598203268417380013863687165686775727976061560608696207173455730179934925684529986102237419507146768083815607566149240438056135058988227916482404733131796310418493418060300571541865427288945087911872630289527954636816219365941817260989104786329938318143577075200571833575709614521758701838099810751 \u0026#39;\u0026#39;\u0026#39; if __name__ == \u0026#34;__main__\u0026#34;: main() As you can see, we have the value of p, e, and c, but we do not have n. If we look at it, we can see that it generates s by doing 18000000 powers and gets q thanks to the value of s. Therefore, we have to try to get the value of s.\nMathematical approach The goal is to reduce the time required to calculate s.\nFollowing Fermat\u0026rsquo;s little theorem:\n$$ a^{p-1}\\hspace{0.2cm}(mod\\hspace{0.2cm}p) = 1 $$ When p is prime. Applying it to our case $$ s = a^{p-2}\\hspace{0.2cm}(mod\\hspace{0.2cm}p) = \\frac{a^{p-1}}{a}\\hspace{0.2cm}(mod\\hspace{0.2cm}p) $$ therefore, we only have to calculate: $$ s = \\frac{1}{a}\\hspace{0.2cm}(mod\\hspace{0.2cm}p) $$\nBy calculating the inverse of the iterator, we can quickly obtain the increment of s.\nSolver Let\u0026rsquo;s put the idea into action\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #!/usr/bin/env python import os import random from Crypto.Util.number import * import gmpy2 p = 11545307730112922786664290405312669819594345207377186481347514368962838475959085036399074594822885814719354871659183685801279739518405830244888530641898849 s = 0 for i in range(1, 18000000): s += gmpy2.invert(i, p) print(f\u0026#34;{s = }\u0026#34;) s = s % p q = gmpy2.next_prime(s) n = p * q c = 114894293598203268417380013863687165686775727976061560608696207173455730179934925684529986102237419507146768083815607566149240438056135058988227916482404733131796310418493418060300571541865427288945087911872630289527954636816219365941817260989104786329938318143577075200571833575709614521758701838099810751 e = 65537 phi = (p-1) * (q-1) d = pow(e, -1, phi) m = pow(c, d, n) print(long_to_bytes(m)) If we execute it, we can see that we get the flag:\n1 2 3 4 ❯ time python3 solver2.py s = mpz(103971141938451865359424516052456680043111979970687239680103277440181119667242055656649027253774602707619853688444079038238256982869565035713747893569070903914899) b\u0026#39;TUCTF{syqow82pam_%shsjQF; ^7dagsWCpsp_#aes}\u0026#39; python3 solver2.py 7,96s user 0,02s system 99% cpu 7,980 total I hope you liked it and learned.\n","date":"2022-12-04T00:00:00Z","image":"https://example.com/post/more-effort-writeup-tuctf/coverMoreEffort2_hu6db6baebb0f556ab3244dd2b5311e772_1143741_120x120_fill_box_smart1_3.png","permalink":"https://example.com/post/more-effort-writeup-tuctf/","title":" More Effort Writeup | TUCTF"},{"content":"TL;DR We are provided with the 1024 - 256 = 768 most significant bits of one of the primes used to compute $n$. Therefore, with the Coppersmith\u0026rsquo;s attack we can find the missing 256 bits and having $p$ it is trivial to break the RSA scheme.\nCode analysis First of all, it is important to understand the source code\nSource code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes, inverse, GCD from secret import FLAG, KEY WELCOME = \u0026#34;\u0026#34;\u0026#34; ************** Welcome to the Gringatts Bank. ************** * * * Fortius Quo Fidelius * * * ************************************************************ \u0026#34;\u0026#34;\u0026#34; class RSA(): def __init__(self, key_length): self.e = 0x10001 phi = 0 prime_length = key_length // 2 while GCD(self.e, phi) != 1: self.p, self.q = getPrime(prime_length), getPrime(prime_length) phi = (self.p - 1) * (self.q - 1) self.n = self.p * self.q self.d = inverse(self.e, phi) def encrypt(self, message): message = bytes_to_long(message) return pow(message, self.e, self.n) def decrypt(self, encrypted_message): message = pow(encrypted_message, self.d, self.n) return long_to_bytes(message) class Bank: def __init__(self, rsa): self.options = \u0026#34;[1] Get public certificate.\\n[2] Calculate Hint.\\n[3] Unlock Vault.\\n\u0026#34; self.shift = 256 self.vaults = { f\u0026#34;vault_{i}\u0026#34;: [b\u0026#34;passphrase\u0026#34;, b\u0026#34;empty\u0026#34;] for i in range(100) } self.rsa = rsa def initializeVault(self, name, passphrase, data): self.vaults[name][0] = passphrase self.vaults[name][1] = data def calculateHint(self): return (self.rsa.p \u0026gt;\u0026gt; self.shift) \u0026lt;\u0026lt; self.shift def enterVault(self, vault, passphrase): vault = self.vaults[vault] if passphrase.encode() == vault[0]: return vault[1].decode() else: print(\u0026#34;\\nFailed to open the vault!\\n\u0026#34;) exit(1) if __name__ == \u0026#34;__main__\u0026#34;: rsa = RSA(2048) bank = Bank(rsa) vault = \u0026#34;vault_68\u0026#34; passphrase = KEY bank.initializeVault(vault, passphrase, FLAG) encrypted_passphrase = rsa.encrypt(bank.vaults[vault][0]) print(f\u0026#34;You managed to retrieve: {hex(encrypted_passphrase)[2:]}\u0026#34;) print(\u0026#34;\\nNow you are ready to enter the bank.\u0026#34;) print(WELCOME) while True: try: print(\u0026#34;Hello, what would you like to do?\\n\u0026#34;) print(bank.options) option = int(input(\u0026#34;\u0026gt; \u0026#34;)) if option == 1: print(f\u0026#34;\\n{bank.rsa.n}\\n{bank.rsa.e}\\n\u0026#34;) elif option == 2: print(f\u0026#34;\\n{bank.calculateHint()}\\n\u0026#34;) print(f\u0026#34;real p : {bank.rsa.p}\u0026#34;) elif option == 3: vault = input(\u0026#34;\\nWhich vault would you like to open: \u0026#34;) passphrase = input(\u0026#34;Enter the passphrase: \u0026#34;) print(f\u0026#34;\\n{bank.enterVault(vault, passphrase)}\\n\u0026#34;) else: \u0026#34;Abort mission!\u0026#34; exit(1) except KeyboardInterrupt: print(\u0026#34;Exiting\u0026#34;) exit(1) except Exception as e: print(f\u0026#34;An error occurred while processing data: {e}\u0026#34;) exit(1) We can see that SELF.SHIFT = 256 and RSA was initialized to have 2048 bit keys: rsa = RSA(2048) but the length of the primes is: key_length // 2\nTherefore, the primes are 1024 bits each. Also, if we look, there is a calculateHint function:\n1 2 def calculateHint(self): return (self.rsa.p \u0026gt;\u0026gt; self.shift) \u0026lt;\u0026lt; self.shift. This function returns the most significant 768 bits of p. If we were able to get p we could easily break the RSA scheme.\nMathematical approach What we are going to do is to construct a polynomial: $$ f(x) = hint + x (mod\\hspace{0.2cm}p) $$ Let us define an $x_{0}$ such that: $$ x_{0} = p - hint $$ $$ f(x_{0}) = 0 $$ Our goal is to find the root $x_{0}$ so that we can recover $p$ in its entirety: $$ p = hint + x_{0} $$\nCoppersmith\u0026rsquo;s attack will help us to find a polynomial $pr$ with small coefficients that has the root $x_{0}$. He does all this through the LLL algorithm.\nI leave you some references about the Coppersmith\u0026rsquo;s attack that surely explain it much better than me:\nhttps://en.wikipedia.org/wiki/Coppersmith%27s_attack\nhttps://github.com/mimoo/RSA-and-LLL-attacks\nhttps://web.eecs.umich.edu/~cpeikert/lic13/lec04.pdf\nhttps://latticehacks.cr.yp.to/rsa.html\nhttps://www.di.ens.fr/~fouque/ens-rennes/coppersmith.pdf\nSolver The final solver is:\n1 2 3 4 5 6 7 8 9 10 n = 26211375773469184001318656141100500763313429420913368001374745099484088122316579885286487097911099553640485465879264776561059641793632440822902474437366178151344614399507216375584746495767257118136660752816908128374718028852908424721616601101869767341034562299604200292062539562260031509249703818987605113732956619399024336428546024215912865109661672719548634299576268423724640604152315140125167475937078671855333168331013934992701158252733536256484092658492790979124858563614501772552940266371220754690019124764001836316364805420248302098449705982955010188607337871438867444775767773706448611787974077408317620890183 e = 65537 nbits = n.nbits() known_bits = 256 hint = 177280817288627322094134834382081312724589047332204205138596571508970320442645568456603184647631801350766801962518302849576529462620705317421396164285474490176804856313329119058781152823294890779368691476727476669843207530678654823924746113011854165428215140997357968931347835865704536810100214150131131351040 PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n)) f = (hint + x) x0 = f.small_roots(X=2^known_bits, beta=0.4)[0] p = hint + x0 print (hint + x0) If we run it we can see that we get the value of $p$.\n1 2 $ sage solver.sage 177280817288627322094134834382081312724589047332204205138596571508970320442645568456603184647631801350766801962518302849576529462620705317421396164285474490176804856313329119058781152823294890779368691476727476669843207530678654824005037352629664972062758886735010264329580233324956801766609726126137579798151 With this value of p we can easily obtain the decrypted message:\n1 2 3 4 5 6 7 8 9 10 11 from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes, inverse, GCD import gmpy2 p = 177280817288627322094134834382081312724589047332204205138596571508970320442645568456603184647631801350766801962518302849576529462620705317421396164285474490176804856313329119058781152823294890779368691476727476669843207530678654824005037352629664972062758886735010264329580233324956801766609726126137579798151 n = 26211375773469184001318656141100500763313429420913368001374745099484088122316579885286487097911099553640485465879264776561059641793632440822902474437366178151344614399507216375584746495767257118136660752816908128374718028852908424721616601101869767341034562299604200292062539562260031509249703818987605113732956619399024336428546024215912865109661672719548634299576268423724640604152315140125167475937078671855333168331013934992701158252733536256484092658492790979124858563614501772552940266371220754690019124764001836316364805420248302098449705982955010188607337871438867444775767773706448611787974077408317620890183 q = n // p e = 65537 phi = (p - 1) * (q - 1) d = gmpy2.invert(e, phi) c = int(\u0026#34;147242eb8f9b480d9211897b5f1577e23fd595f23f290a0ec5b006c35cd843307749db797c523ca906904c078c04300a6f3af77f15ce19382d40f86b0709ebf23f2fb405d2bfa0dd649813004d83e6eb08a2ccfa8af7a94c69a8b6eb10a2478c181bfec8dc17a8749bd9e50394dd59b527375fdb4095efd95234876e7548c08e452438a081f9b0d7b5d11e0c24bf94946ab772ce7979691930d034829d0a9bb50835d848f4de4850c6c566ea7ba761ed747b7353934924d301e64e6f123f5be140af009acc13f019b5953bf152090752448995f84e6753737697ba8246a966e1357664e93597147bca6c5f4a9abe299382a67a1a5f6c081bd6071e05694c3a23\u0026#34;, 16) m = pow(c, d, n) print(long_to_bytes(m)) Obtained message:\n1 2 $ python3 solver.py b\u0026#34;The_horcrux_is_Helga_Hufflepuff\u0026#39;s_cup\u0026#34; Flag: We introduce The_horcrux_is_Helga_Hufflepuff's_cup as password in the server to open the vault and get the flag:\n1 HTB{LLL_4nd_c00p325m17h_15_57111_m491c_70_my_3y35} I hope you liked it and learned.\n","date":"2022-12-02T00:00:00Z","image":"https://example.com/post/bank-er-smith-writeup-hack-the-box-uni-ctf/cover_hu4fd12123899c49c5fd3acf52779a677b_2086628_120x120_fill_box_smart1_3.png","permalink":"https://example.com/post/bank-er-smith-writeup-hack-the-box-uni-ctf/","title":"Bank-er-smith Writeup | Hack The Box Uni CTF"},{"content":"TL;DR To obtain the flag, we have to get a number that when we pass it to the Miller Rabin primality test, returns that it is not prime and if we pass it to the isPrime function of the Crypto.Util.number library, it tells us that it is prime. Thus, we have to fool the Miller Rabin algorithm. To do this, we can use Carmichael\u0026rsquo;s numbers.\nCode analysis First of all, it is important to understand the source code\nSource code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 from secret import FLAG from Crypto.Util.number import isPrime import socketserver import signal class Handler(socketserver.BaseRequestHandler): def handle(self): signal.alarm(0) main(self.request) class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass def sendMessage(s, msg): s.send(msg.encode()) def receiveMessage(s, msg): sendMessage(s, msg) return s.recv(4096).decode().strip() def generate_basis(n): basis = [True] * n for i in range(3, int(n**0.5) + 1, 2): if basis[i]: basis[i * i::2 * i] = [False] * ((n - i * i - 1) // (2 * i) + 1) return [2] + [i for i in range(3, n, 2) if basis[i]] def millerRabin(n, b): basis = generate_basis(300) if n == 2 or n == 3: return True if n % 2 == 0: return False r, s = 0, n - 1 while s % 2 == 0: r += 1 s //= 2 for b in basis: x = pow(b, s, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True def _isPrime(p): if p \u0026lt; 1: return False if (p.bit_length() \u0026lt;= 600) and (p.bit_length() \u0026gt; 1500): return False if not millerRabin(p, 300): return False return True def main(s): p = receiveMessage(s, \u0026#34;Give p: \u0026#34;) try: p = int(p) except: sendMessage(s, \u0026#34;Error!\u0026#34;) if _isPrime(p) and not isPrime(p): sendMessage(s, FLAG) else: sendMessage(s, \u0026#34;Conditions not satisfied!\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: socketserver.TCPServer.allow_reuse_address = True server = ReusableTCPServer((\u0026#34;0.0.0.0\u0026#34;, 1337), Handler) server.serve_forever() To obtain the flag we have to pass these checks:\n1 if _isPrime(p) and not isPrime(p): The function _isPrime calls millerRabin and isPrime calls such function from the Crypto.Util.number library.\nSolver Surfing the Internet, we can see that Carmichael numbers have a particular relationship with primality tests based on Fermat\u0026rsquo;s Little Theorem such as Miller-Rabin.\nHere you can find information about Carmichael\u0026rsquo;s numbers: https://en.wikipedia.org/wiki/Carmichael_number\nThe most important part is:\nThis makes tests based on Fermat\u0026rsquo;s Little Theorem less effective than strong probable prime tests such as the Baillie–PSW primality test and the Miller–Rabin primality test.\nThus, we can try to use this information to bypass the check. We can calculate a Carmichael number following the information in wikipedia:\n1 2 3 4 #!/usr/bin/env python p = 29674495668685510550154174642905332730771991799853043350995075531276838753171770199594238596428121188033664754218345562493168782883 number = p * (313 * (p-1) + 1 ) * (353 * (p-1) + 1) print(f\u0026#34;{number = }\u0026#34;) If we execute it, we can see that we get the number:\n1 Number = 2887148238050771212671429597130393991977609459279722700926516024197432303799152733116328983144639225941977803110929349655578418949441740933805615113979999421542416933972905423711002751042080134966731755152859226962916775325475044445856101949404200039904432116776619949629539250452698719329070373564032273701278453899126120309244841494728976885406024976768122077071687938121709811322297802059565867 Flag:\n1 2 3 ❯ nc 176.61.85.130 31431 Give p: 2887148238050771212671429597130393991977609459279722700926516024197432303799152733116328983144639225941977803110929349655578418949441740933805615113979999421542416933972905423711002751042080134966731755152859226962916775325475044445856101949404200039904432116776619949629539250452698719329070373564032273701278453899126120309244841494728976885406024976768122077071687938121709811322297802059565867 HTB{c42m1ch431_num8325_423_fun_p53ud0p21m35} I hope you liked it and learned.\n","date":"2022-10-28T00:00:00Z","image":"https://example.com/post/fast-carmichael-writeup-hack-the-boo/CarmichaelCover_hu5ea5adbdd50db7b3134bd92c79e59143_1586316_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/post/fast-carmichael-writeup-hack-the-boo/","title":"Fast Carmichael Writeup | Hack The Boo"},{"content":"It is a simple challenge, but it is necessary to realize how to obtain f. Something that, initially, can be a bit tricky.\nTL;DR We can obtain the value of f if we apply GCD on C1-C2 and N\nCode analysis First of all, it is important to understand the source code\nSource code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from Crypto.Util.number import bytes_to_long, getStrongPrime from random import randint FLAG = b\u0026#39;HTB{????????????????????????????????????????????}\u0026#39; def key_gen(bits): p, q = getStrongPrime(bits), getStrongPrime(bits) N = p * q return N, (p, q) def encrypt(m, N, f): e1, e2 = randint(2, N - 2), randint(2, N - 2) c1 = (pow(f, e1, N) + m) % N c2 = (pow(f, e2, N) + m) % N return (e1, c1), (e2, c2) def main(): N, priv = key_gen(1024) m = bytes_to_long(FLAG) (e1, c1), (e2, c2) = encrypt(m, N, priv[0]) with open(\u0026#39;out.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(f\u0026#39;N = {N}\\n(e1, c1) = ({e1}, {c1})\\n(e2, c2) = ({e2}, {c2})\\n\u0026#39;) if __name__ == \u0026#34;__main__\u0026#34;: main() Output:\n1 2 3 N = 25458200992030509733740123651871827168179694737564741891817013763410533831135578900317404987414083347009443171337016804117994550747038777609425522146275786823385218489896468142658492353321920860029284041857237273061376882168336089921980034356731735024837853873907395117925738744950932927683784527829300499629044776530663084875991411120648155572219472426590747952180037566734905079883718263249789131313731453855593891997376222635496337534679814697188141565730768050813250191975439504290665602928172394124501396491438097237093345376202142503439944034846839870643057174427346860377971316738504003909365471892007511334129 (e1, c1) = (22255763231110249841946619835451544743470788953822278626567823902873888725104180401047359514978597528256727783972109939326623409435352523707077685530090905587264556011558283062584063790610407522064244766804545192800000203519996147931257064951519705687708204481851413899370853107413015511963924826116255617048471033727588623329910848658324118717242497443676679226618430348230146770121025920211016222285978389380202889753020268614144716241830764562717015776308425373054119742788593926393822433887270639369774139542440755201713961244129409678232953199572105700556795757766046717275157050721726002297647024020428198870290, 19074438470072195427966520314234457847008607427606084653244579403273587717215359437848959151287968653813774451872243596539852961112790372328452176435310940366312355444995843216994547119328105950997441430508803799696108202263077660206667410037895728991246260073976495701990246589717169815787627260333746927676703415397948299928151669728670970891826725671026488571268125861689964688240713660432174319415041362820791863237794347031803574182264640071528640168842529541888996148513070006266317160300336104047046565614107490019016833308549850299600989228190163831642944507973854553499903518264459385900876967183424703346566) (e2, c2) = (23295046285127774160603234291301851851887586336491694096135804083341667982196486623010787985772884401302006627480506928365762168889259124596656609547973623161028214128429382170008181185180817200188852310143707964673736007253037970626819969310508212349854949150027746456459910448148518206090222496335254237639366458956363901115228820515207791697374943745570543635069929211464017776268424656451494147324386568859163866168248303418756480467046005765139197217754018136577337642795325944222997798231137981998354508181409469926672642302422740898720854693114056342834487668008885129303781190655860432910789997267090661459286, 17147905252678781157626731164660022679389951402035723790864177724472811805536492684462105274963820085525923148442586230016346022360533813239980197823588694113614328942373594914090007235565086360669401527248700861049825216638433673668883632064731716051799766945737234155585371938261291032941617911654796216200373195747432329591657679097825944679339369336644061159658436125778459206858632826310294115276289447751653250081978372776233383658861171699105292372718533428579168281346425439711770636421673291051002416067073005799659684303566722822458673952580001750804105442227754799536262315625088085767607467446614116889593) Mathematical approach The goal is to try to clear f so that we can factor N easily:\n$$ c1 - c2 \\cong (f^{e1} - f^{e2}) \\times \\frac{f}{f}\\hspace{0.2cm}(mod\\hspace{0.2cm}N) $$ Also, we know that: $$ (f^{e1} - f^{e2}) \\times \\frac{f}{f} = \\frac{f^{e1}}{f} - \\frac{f^{e2}}{f} = (f^{e1} \\times f^{-1}) - (f^{e2} - f^{-1}) = (f^{e1-1} - f^{e2-1}) \\times f $$ therefore: $$ c1 - c2 \\cong (f^{e1-1} - f^{e2-1}) \\times f\\hspace{0.2cm}(mod\\hspace{0.2cm}N) $$\nAdditionally, we know that:\n$$ N = f * q $$\nwe can eliminate the congruence and formulate it as follows:\n$$ c1 - c2 = f \\times (f^{e1-1} - p^{e2-1}) + (k \\times f \\times q) $$\nWe are very close to achieving this\n$$ c1 - c2 = f \\times (f^{e1-1} - p^{e2-1} + k \\times q) $$\nWe have already succeeded in isolating the f. So if we apply the GCD on this expression and N, we will obtain f. $$ f = \\gcd{(C1-C2, N)} $$\nSolver Let\u0026rsquo;s put the idea into action\n1 2 3 4 5 6 7 8 9 10 11 #!/usr/bin/env python from Crypto.Util.number import * N = 25458200992030509733740123651871827168179694737564741891817013763410533831135578900317404987414083347009443171337016804117994550747038777609425522146275786823385218489896468142658492353321920860029284041857237273061376882168336089921980034356731735024837853873907395117925738744950932927683784527829300499629044776530663084875991411120648155572219472426590747952180037566734905079883718263249789131313731453855593891997376222635496337534679814697188141565730768050813250191975439504290665602928172394124501396491438097237093345376202142503439944034846839870643057174427346860377971316738504003909365471892007511334129 (e1, c1) = (22255763231110249841946619835451544743470788953822278626567823902873888725104180401047359514978597528256727783972109939326623409435352523707077685530090905587264556011558283062584063790610407522064244766804545192800000203519996147931257064951519705687708204481851413899370853107413015511963924826116255617048471033727588623329910848658324118717242497443676679226618430348230146770121025920211016222285978389380202889753020268614144716241830764562717015776308425373054119742788593926393822433887270639369774139542440755201713961244129409678232953199572105700556795757766046717275157050721726002297647024020428198870290, 19074438470072195427966520314234457847008607427606084653244579403273587717215359437848959151287968653813774451872243596539852961112790372328452176435310940366312355444995843216994547119328105950997441430508803799696108202263077660206667410037895728991246260073976495701990246589717169815787627260333746927676703415397948299928151669728670970891826725671026488571268125861689964688240713660432174319415041362820791863237794347031803574182264640071528640168842529541888996148513070006266317160300336104047046565614107490019016833308549850299600989228190163831642944507973854553499903518264459385900876967183424703346566) (e2, c2) = (23295046285127774160603234291301851851887586336491694096135804083341667982196486623010787985772884401302006627480506928365762168889259124596656609547973623161028214128429382170008181185180817200188852310143707964673736007253037970626819969310508212349854949150027746456459910448148518206090222496335254237639366458956363901115228820515207791697374943745570543635069929211464017776268424656451494147324386568859163866168248303418756480467046005765139197217754018136577337642795325944222997798231137981998354508181409469926672642302422740898720854693114056342834487668008885129303781190655860432910789997267090661459286, 17147905252678781157626731164660022679389951402035723790864177724472811805536492684462105274963820085525923148442586230016346022360533813239980197823588694113614328942373594914090007235565086360669401527248700861049825216638433673668883632064731716051799766945737234155585371938261291032941617911654796216200373195747432329591657679097825944679339369336644061159658436125778459206858632826310294115276289447751653250081978372776233383658861171699105292372718533428579168281346425439711770636421673291051002416067073005799659684303566722822458673952580001750804105442227754799536262315625088085767607467446614116889593) f = GCD(N, c1 - c2) m = long_to_bytes(c1 - pow(f, e1, N) % N) print(m) If we execute it, we can see that we get the flag:\nFlag:\n1 2 ❯ python3 solverSpookyRSA.py b\u0026#39;HTB{5h45_w4$_sUpp0s3d_50_b3_m0r3_s3cUr3_th4n_R$4}\u0026#39; I hope you liked it and learned.\n","date":"2022-10-28T00:00:00Z","image":"https://example.com/post/spooky-rsa-writeup-hack-the-boo/coverSpookyGrey2_hud0bc4ac7a7e710e3c50db796ed01cdff_1387720_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/post/spooky-rsa-writeup-hack-the-boo/","title":"Spooky RSA Writeup | Hack The Boo"}]